> Title: 浏览器的事件循环
>
> Author: darkTang
> 
> Time: 2023-08-11
>
> Category: 浏览器

## 1. 介绍
浏览器是一个多进程多线程的应用程序。这里主要介绍浏览器的渲染进程。渲染进程启动后，会开启一个渲染主线程，主线程处理的任务包括但不限于：
- 解析HTML、CSS
- 计算样式
- 执行全局JS代码
- 布局、绘制、渲染
- 执行回调
- ......

> 为什么渲染进程不使用多个线程来处理这些事情？
>
> 因为渲染进程需要保证页面的渲染顺序和渲染结果的正确性，而多线程并发处理可能会导致页面元素的错乱、渲染结果的不确定性等问题。

## 2. 主线程如何调度任务
![image-20220809223027806](http://mdrs.yuanjin.tech/img/202208092230847.png)
- 开始时，浏览器会进入一个无限循环。
- 每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完一个后进入下一次循环；如果没有，则进入休眠状态。
- 其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务

整个过程称之为**事件循环**。

## 3. 异步
代码在执行过程中，会遇到一些无法立即执行的任务，比如：
- 计时完成后需要执行的任务 —— `setTimeout`、`setInterval`
- 网络通信完成后需要执行的任务 —— `XHR`、`Fetch`
- 用户操作后需要执行的任务 —— `addEventListener`

如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于「阻塞」的状态，从而导致浏览器「卡死」 。
![image-20220810104344296](http://mdrs.yuanjin.tech/img/202208101043348.png)
**渲染主线程承担着极其重要的工作，无论如何都不能阻塞！**

因此，浏览器选择**异步**来解决这个问题。
![image-20220810104858857](http://mdrs.yuanjin.tech/img/202208101048899.png)

## 4. 任务有优先级吗
任务没有优先级，在消息队列中先进先出。但消息队列是有优先级的。
根据 W3C 的最新解释:
- 每个任务都有一个任务类型，**同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列**。在一次事件循环中，浏览器可以根据**实际情况**从不同的队列中取出任务执行。
- 浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行。

> 随着浏览器的复杂度急剧提升，W3C 不再使用宏队列的说法。

在目前 chrome 的实现中，至少包含了下面的队列：

- 延时队列：用于存放计时器到达后的回调任务，优先级「中」
- 交互队列：用于存放用户操作后产生的事件处理任务，优先级「高」
- 微队列：用户存放需要最快执行的任务，优先级「最高」

> 添加任务到微队列的主要方式主要是使用 Promise、MutationObserver。

例如：
```js
// 立即将一个函数添加到微任务队列
Promise.reselve().then(函数)
```

## 5. 实例
1. JS会阻碍渲染
```html
<h1>AAA</h1>
<button>change</button>
<script>
  var h1 = document.querySelector("h1");
  var btn = document.querySelector("button")
  // 死循环指定的时间
  function delay(duration) {
    var start = Date.now();
    while (Date.now() - start <script duration) {}
  }
  btn.onclick = function () {
    h1.textContent = "BBB";
    delay(3000);
  };
</script>
```
- 效果：页面开始展示AAA，点击按钮3s后展示BBB。
- 分析：
  - 主线程开始执行全局JS，从上向下依次执行，当执行到点击事件时，会将点击事件交给交互线程来监听按钮点击，而自身会结束这个任务。主线程进入休眠状态。
  - 当用户点击按钮时，交互线程会将这个回调函数包装成任务放到消息队列中，从而会唤醒主线程来执行这个队列中的任务。
  - 先执行回调的`h1.textContent = "BBB";`，会产生一个新任务：绘制任务放入到消息队列中。
  - 然后再执行`delay(3000);`，死循环3s，3s后结束主线程任务。
  - 同理主线程再去执行绘制任务，页面才会显示。

2. 输出顺序
```js
function a() {
  console.log(1)
  Promise.resolve().then(() => {
    console.log(2)
  })
}
setTimeout(() => {
  console.log(3)
  Promise.resolve().then(a)
}, 0)
Promise.resolve().then(() => {
  console.log(4)
})
console.log(5)

// 打印顺序：5 4 3 1 2
```
